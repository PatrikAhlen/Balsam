# TODO: Cleanup, remove unnecessary 
image:
  registry: docker.io
  repository: bitnami/minio
  tag: 2022.12.7-debian-11-r0

clientImage:
  registry: docker.io
  repository: bitnami/minio-client
  tag: 2022.12.2-debian-11-r1
  digest: ""

extraEnvVars:
  - name: MINIO_IDENTITY_OPENID_CONFIG_URL
    value: http://keycloak.<YOUR-DOMAIN>/realms/Balsam/.well-known/openid-configuration
  - name: MINIO_IDENTITY_OPENID_CLIENT_ID
    value: demo
  - name: MINIO_IDENTITY_OPENID_CLIENT_SECRET
    value: <YOUR-KEYCLOAK-SECRET>
  - name: MINIO_IDENTITY_OPENID_CLAIM_NAME
    value: roles
  - name: MINIO_IDENTITY_OPENID_SCOPES
    value: balsamscope
  - name: MINIO_IDENTITY_OPENID_REDIRECT_URI
    value: http://minio.keycloak.<YOUR-DOMAIN>/oauth_callback
  
ingress:
  
  enabled: true
 
  hostname: minio.<YOUR-DOMAIN>
  
  annotations:
    kubernetes.io/ingress.class: "contour"
    cert-manager.io/cluster-issuer: ca-issuer
    ingress.kubernetes.io/force-ssl-redirect: "true"
    projectcontour.io/websocket-routes: /ws
  ## @param ingress.tls Enable TLS configuration for the hostname defined at `ingress.hostname` parameter
  ## TLS certificates will be retrieved from a TLS secret with name: `{{- printf "%s-tls" .Values.ingress.hostname }}`
  ## You can:
  ##   - Use the `ingress.secrets` parameter to create this TLS secret
  ##   - Rely on cert-manager to create it by setting the corresponding annotations
  ##   - Rely on Helm to create self-signed certificates by setting `ingress.selfSigned=true`
  ##
  tls: true
  ## @param ingress.selfSigned Create a TLS secret for this ingress record using self-signed certificates generated by Helm
  ##
  selfSigned: false
  ## @param ingress.extraHosts The list of additional hostnames to be covered with this ingress record.
  ## Most likely the hostname above will be enough, but in the event more hosts are needed, this is an array
  ## e.g:
  ## extraHosts:
  ##   - name: minio.local
  ##     path: /
  ##
  extraHosts: []
  ## @param ingress.extraPaths Any additional paths that may need to be added to the ingress under the main host
  ## For example: The ALB ingress controller requires a special rule for handling SSL redirection.
  ## extraPaths:
  ## - path: /*
  ##   backend:
  ##     serviceName: ssl-redirect
  ##     servicePort: use-annotation
  ##
  extraPaths: []
  ## @param ingress.extraTls The tls configuration for additional hostnames to be covered with this ingress record.
  ## see: https://kubernetes.io/docs/concepts/services-networking/ingress/#tls
  ## e.g:
  ## extraTls:
  ## - hosts:
  ##     - minio.local
  ##   secretName: minio.local-tls
  ##
  extraTls: []
  ## @param ingress.secrets If you're providing your own certificates, please use this to add the certificates as secrets
  ## key and certificate are expected in PEM format
  ## name should line up with a secretName set further up
  ##
  ## If it is not set and you're using cert-manager, this is unneeded, as it will create a secret for you with valid certificates
  ## If it is not set and you're NOT using cert-manager either, self-signed certificates will be created valid for 365 days
  ## It is also possible to create and manage the certificates outside of this helm chart
  ## Please see README.md for more information
  ##
  ## Example
  ## secrets:
  ##   - name: minio.local-tls
  ##     key: ""
  ##     certificate: ""
  ##
  secrets: []
  ## @param ingress.extraRules Additional rules to be covered with this ingress record
  ## ref: https://kubernetes.io/docs/concepts/services-networking/ingress/#ingress-rules
  ## e.g:
  ## extraRules:
  ## - host: example.local
  ##     http:
  ##       path: /
  ##       backend:
  ##         service:
  ##           name: example-svc
  ##           port:
  ##             name: http
  ##
  extraRules: []

## Configure the ingress resource that allows you to access the
## MinIO&reg; API. Set up the URL
## ref: https://kubernetes.io/docs/user-guide/ingress/
##
apiIngress:
  ## @param apiIngress.enabled Enable ingress controller resource for MinIO API
  ##
  enabled: true
  ## @param apiIngress.apiVersion Force Ingress API version (automatically detected if not set)
  ##
  apiVersion: ""
  ## @param apiIngress.ingressClassName IngressClass that will be be used to implement the Ingress (Kubernetes 1.18+)
  ## This is supported in Kubernetes 1.18+ and required if you have more than one IngressClass marked as the default for your cluster.
  ## ref: https://kubernetes.io/blog/2020/04/02/improvements-to-the-ingress-api-in-kubernetes-1.18/
  ##
  ingressClassName: ""
  ## @param apiIngress.hostname Default host for the ingress resource
  ##
  hostname: minio.<YOUR-DOMAIN>
  ## @param apiIngress.path The Path to MinIO&reg;. You may need to set this to '/*' in order to use this with ALB ingress controllers.
  ##
  path: /
  ## @param apiIngress.pathType Ingress path type
  ##
  pathType: ImplementationSpecific
  ## @param apiIngress.servicePort Service port to be used
  ## Default is http. Alternative is https.
  ##
  servicePort: minio-api
  ## @param apiIngress.annotations Additional annotations for the Ingress resource. To enable certificate autogeneration, place here your cert-manager annotations.
  ## For a full list of possible ingress annotations, please see
  ## ref: https://github.com/kubernetes/ingress-nginx/blob/master/docs/user-guide/nginx-configuration/annotations.md
  ## Use this parameter to set the required annotations for cert-manager, see
  ## ref: https://cert-manager.io/docs/usage/ingress/#supported-annotations
  ##
  ## e.g:
  ## annotations:
  ##   kubernetes.io/ingress.class: nginx
  ##   cert-manager.io/cluster-issuer: cluster-issuer-name
  ##
  annotations: {}
  ## @param apiIngress.tls Enable TLS configuration for the hostname defined at `apiIngress.hostname` parameter
  ## TLS certificates will be retrieved from a TLS secret with name: `{{- printf "%s-tls" .Values.apiIngress.hostname }}`
  ## You can:
  ##   - Use the `ingress.secrets` parameter to create this TLS secret
  ##   - Rely on cert-manager to create it by setting the corresponding annotations
  ##   - Rely on Helm to create self-signed certificates by setting `ingress.selfSigned=true`
  ##
  tls: false
  ## @param apiIngress.selfSigned Create a TLS secret for this ingress record using self-signed certificates generated by Helm
  ##
  selfSigned: false
  ## @param apiIngress.extraHosts The list of additional hostnames to be covered with this ingress record.
  ## Most likely the hostname above will be enough, but in the event more hosts are needed, this is an array
  ## e.g:
  ## extraHosts:
  ##   - name: minio.local
  ##     path: /
  ##
  extraHosts: []
  ## @param apiIngress.extraPaths Any additional paths that may need to be added to the ingress under the main host
  ## For example: The ALB ingress controller requires a special rule for handling SSL redirection.
  ## extraPaths:
  ## - path: /*
  ##   backend:
  ##     serviceName: ssl-redirect
  ##     servicePort: use-annotation
  ##
  extraPaths: []
  ## @param apiIngress.extraTls The tls configuration for additional hostnames to be covered with this ingress record.
  ## see: https://kubernetes.io/docs/concepts/services-networking/ingress/#tls
  ## e.g:
  ## extraTls:
  ## - hosts:
  ##     - minio.local
  ##   secretName: minio.local-tls
  ##
  extraTls: []
  ## @param apiIngress.secrets If you're providing your own certificates, please use this to add the certificates as secrets
  ## key and certificate are expected in PEM format
  ## name should line up with a secretName set further up
  ##
  ## If it is not set and you're using cert-manager, this is unneeded, as it will create a secret for you with valid certificates
  ## If it is not set and you're NOT using cert-manager either, self-signed certificates will be created valid for 365 days
  ## It is also possible to create and manage the certificates outside of this helm chart
  ## Please see README.md for more information
  ##
  ## Example
  ## secrets:
  ##   - name: minio.local-tls
  ##     key: ""
  ##     certificate: ""
  ##
  secrets: []
  ## @param apiIngress.extraRules Additional rules to be covered with this ingress record
  ## ref: https://kubernetes.io/docs/concepts/services-networking/ingress/#ingress-rules
  ## e.g:
  ## extraRules:
  ## - host: example.local
  ##     http:
  ##       path: /
  ##       backend:
  ##         service:
  ##           name: example-svc
  ##           port:
  ##             name: http
  ##
  extraRules: []
## NetworkPolicy parameters
##
networkPolicy:
  ## @param networkPolicy.enabled Enable the default NetworkPolicy policy
  ##
  enabled: false
  ## @param networkPolicy.allowExternal Don't require client label for connections
  ## When set to false, only pods with the correct client label will have network access to the port MinIO&reg; is
  ## listening on. When true, MinIO&reg; will accept connections from any source (with the correct destination port).
  ##
  allowExternal: true
  ## @param networkPolicy.extraFromClauses Allows to add extra 'from' clauses to the NetworkPolicy
  extraFromClauses: {}
  ## Example
  ## extraFromClauses:
  ## - podSelector:
  ##     matchLabels:
  ##       a: b

## @section Persistence parameters

## Enable persistence using Persistent Volume Claims
## ref: https://kubernetes.io/docs/user-guide/persistent-volumes/
##
persistence:
  ## @param persistence.enabled Enable MinIO&reg; data persistence using PVC. If false, use emptyDir
  ##
  enabled: true
  ## @param persistence.storageClass PVC Storage Class for MinIO&reg; data volume
  ## If defined, storageClassName: <storageClass>
  ## If set to "-", storageClassName: "", which disables dynamic provisioning
  ## If undefined (the default) or set to null, no storageClassName spec is
  ##   set, choosing the default provisioner.  (gp2 on AWS, standard on
  ##   GKE, AWS & OpenStack)
  ##
  storageClass: ""
  ## @param persistence.mountPath Data volume mount path
  ##
  mountPath: /data
  ## @param persistence.accessModes PVC Access Modes for MinIO&reg; data volume
  ##
  accessModes:
    - ReadWriteOnce
  ## @param persistence.size PVC Storage Request for MinIO&reg; data volume
  ##
  size: 50Gi
  ## @param persistence.annotations Annotations for the PVC
  ##
  annotations: {}
  ## @param persistence.existingClaim Name of an existing PVC to use (only in `standalone` mode)
  ##
  existingClaim: ""

## @section Volume Permissions parameters

## Init containers parameters:
## volumePermissions: Change the owner and group of the persistent volume mountpoint to runAsUser:fsGroup values from the securityContext section.
##
volumePermissions:
  ## @param volumePermissions.enabled Enable init container that changes the owner and group of the persistent volume(s) mountpoint to `runAsUser:fsGroup`
  ##
  enabled: false
  ## @param volumePermissions.image.registry Init container volume-permissions image registry
  ## @param volumePermissions.image.repository Init container volume-permissions image repository
  ## @param volumePermissions.image.tag Init container volume-permissions image tag (immutable tags are recommended)
  ## @param volumePermissions.image.digest Init container volume-permissions image digest in the way sha256:aa.... Please note this parameter, if set, will override the tag
  ## @param volumePermissions.image.pullPolicy Init container volume-permissions image pull policy
  ## @param volumePermissions.image.pullSecrets Specify docker-registry secret names as an array
  ##
  image:
    registry: docker.io
    repository: bitnami/bitnami-shell
    tag: 11-debian-11-r57
    digest: ""
    pullPolicy: IfNotPresent
    ## Optionally specify an array of imagePullSecrets.
    ## Secrets must be manually created in the namespace.
    ## ref: https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/
    ## e.g:
    ## pullSecrets:
    ##   - myRegistryKeySecretName
    ##
    pullSecrets: []
  ## Init container' resource requests and limits
  ## ref: https://kubernetes.io/docs/user-guide/compute-resources/
  ## We usually recommend not to specify default resources and to leave this as a conscious
  ## choice for the user. This also increases chances charts run on environments with little
  ## resources, such as Minikube. If you do want to specify resources, uncomment the following
  ## lines, adjust them as necessary, and remove the curly braces after 'resources:'.
  ## @param volumePermissions.resources.limits Init container volume-permissions resource limits
  ## @param volumePermissions.resources.requests Init container volume-permissions resource requests
  ##
  resources:
    ## Example:
    ## limits:
    ##    cpu: 500m
    ##    memory: 1Gi
    limits: {}
    requests: {}
  ## Init container' Security Context
  ## Note: the chown of the data folder is done to containerSecurityContext.runAsUser
  ## and not the below volumePermissions.containerSecurityContext.runAsUser
  ## @param volumePermissions.containerSecurityContext.runAsUser User ID for the init container
  ##
  containerSecurityContext:
    runAsUser: 0

## @section RBAC parameters

## Specifies whether a ServiceAccount should be created
##
serviceAccount:
  ## @param serviceAccount.create Enable the creation of a ServiceAccount for MinIO&reg; pods
  ##
  create: true
  ## @param serviceAccount.name Name of the created ServiceAccount
  ## If not set and create is true, a name is generated using the common.names.fullname template
  ##
  name: ""
  ## @param serviceAccount.automountServiceAccountToken Enable/disable auto mounting of the service account token
  ##
  automountServiceAccountToken: true
  ## @param serviceAccount.annotations Custom annotations for MinIO&reg; ServiceAccount
  ##
  annotations: {}

## @section Other parameters

## MinIO&reg; Pod Disruption Budget configuration in distributed mode.
## If MinIO&reg; Gateway is enabled, creates a Pod Disruption Budget for the Gateway instead (mutually exclusive with distributed mode).
## ref: https://kubernetes.io/docs/tasks/run-application/configure-pdb/
##
pdb:
  ## @param pdb.create Enable/disable a Pod Disruption Budget creation
  ##
  create: false
  ## @param pdb.minAvailable Minimum number/percentage of pods that must still be available after the eviction
  ##
  minAvailable: 1
  ## @param pdb.maxUnavailable Maximum number/percentage of pods that may be made unavailable after the eviction
  ##
  maxUnavailable: ""

## @section Metrics parameters

metrics:
  ## @param metrics.prometheusAuthType Authentication mode for Prometheus (`jwt` or `public`)
  ## To allow public access without authentication for prometheus metrics set environment as follows.
  ##
  prometheusAuthType: public
  ## Prometheus Operator ServiceMonitor configuration
  ##
  serviceMonitor:
    ## @param metrics.serviceMonitor.enabled If the operator is installed in your cluster, set to true to create a Service Monitor Entry
    ##
    enabled: false
    ## @param metrics.serviceMonitor.namespace Namespace which Prometheus is running in
    ##
    namespace: ""
    ## @param metrics.serviceMonitor.labels Extra labels for the ServiceMonitor
    ##
    labels: {}
    ## @param metrics.serviceMonitor.jobLabel The name of the label on the target service to use as the job name in Prometheus
    ##
    jobLabel: ""
    ## @param metrics.serviceMonitor.path HTTP path to scrape for metrics
    ##
    path: /minio/v2/metrics/cluster
    ## @param metrics.serviceMonitor.interval Interval at which metrics should be scraped
    ##
    interval: 30s
    ## @param metrics.serviceMonitor.scrapeTimeout Specify the timeout after which the scrape is ended
    ## e.g:
    ## scrapeTimeout: 30s
    scrapeTimeout: ""
    ## @param metrics.serviceMonitor.metricRelabelings MetricRelabelConfigs to apply to samples before ingestion
    ##
    metricRelabelings: []
    ## @param metrics.serviceMonitor.relabelings Metrics relabelings to add to the scrape endpoint, applied before scraping
    ##
    relabelings: []
    ## @param metrics.serviceMonitor.honorLabels Specify honorLabels parameter to add the scrape endpoint
    ##
    honorLabels: false
    ## @param metrics.serviceMonitor.selector Prometheus instance selector labels
    ## ref: https://github.com/bitnami/charts/tree/main/bitnami/prometheus-operator#prometheus-configuration
    ##
    selector: {}
    ## @param metrics.serviceMonitor.apiVersion ApiVersion for the serviceMonitor Resource (defaults to "monitoring.coreos.com/v1")
    apiVersion: ""

  ## Prometheus Operator PrometheusRule configuration
  ##
  prometheusRule:
    ## @param metrics.prometheusRule.enabled Create a Prometheus Operator PrometheusRule (also requires `metrics.enabled` to be `true` and `metrics.prometheusRule.rules`)
    ##
    enabled: false
    ## @param metrics.prometheusRule.namespace Namespace for the PrometheusRule Resource (defaults to the Release Namespace)
    ##
    namespace: ""
    ## @param metrics.prometheusRule.additionalLabels Additional labels that can be used so PrometheusRule will be discovered by Prometheus
    ##
    additionalLabels: {}
    ## @param metrics.prometheusRule.rules Prometheus Rule definitions
      # - alert: minio cluster nodes offline
      #   annotations:
      #     summary: "minio cluster nodes offline"
      #     description: "minio cluster nodes offline, pod {{`{{`}} $labels.pod {{`}}`}} service {{`{{`}} $labels.job {{`}}`}} offline"
      #   for: 10m
      #   expr: minio_cluster_nodes_offline_total > 0
      #   labels:
      #     severity: critical
      #     group: PaaS
    ##
    rules: []

## @section Gateway parameters

gateway:
  ## @param gateway.enabled Use MinIO&reg; as Gateway for other storage systems
  ##
  enabled: false
  ## @param gateway.type Gateway type. Supported types are: `azure`, `gcs`, `nas`, `s3`
  ## ref: https://docs.minio.io/docs/minio-gateway-for-azure
  ## ref: https://docs.minio.io/docs/minio-gateway-for-gcs
  ## ref: https://docs.minio.io/docs/minio-gateway-for-nas
  ## ref: https://docs.minio.io/docs/minio-gateway-for-s3
  ##
  type: s3
  ## @param gateway.replicaCount Number of MinIO&reg; Gateway replicas
  ##
  replicaCount: 4
  ## @param gateway.updateStrategy.type Update strategy type for MinIO&reg; Gateway replicas
  updateStrategy:
    type: Recreate
  ## Autoscaling configuration for MinIO&reg; Gateway. overrides gateway.replicaCount if enabled
  ## @param gateway.autoscaling.enabled Enable autoscaling for MinIO&reg; Gateway deployment
  ## @param gateway.autoscaling.minReplicas Minimum number of replicas to scale back
  ## @param gateway.autoscaling.maxReplicas Maximum number of replicas to scale out
  ## @param gateway.autoscaling.targetCPU Target CPU utilization percentage
  ## @param gateway.autoscaling.targetMemory Target Memory utilization percentage
  autoscaling:
    enabled: false
    minReplicas: "4"
    maxReplicas: "4"
    targetCPU: ""
    targetMemory: ""
  ## @param gateway.priorityClassName Pod priority class name for MinIO&reg; Gateway
  ##
  priorityClassName: ""
  ## Gateway authentication configuration
  ##
  auth:
    ## Authentication configuration for Azure. Ignored unless type=azure
    ## @param gateway.auth.azure.accessKey Access key to access MinIO&reg; using Azure Gateway
    ## @param gateway.auth.azure.secretKey Secret key to access MinIO&reg; using Azure Gateway
    ## @param gateway.auth.azure.serviceEndpoint Azure Blob Storage custom endpoint
    ## @param gateway.auth.azure.storageAccountName Azure Storage Account Name to use to access Azure Blob Storage
    ## @param gateway.auth.azure.storageAccountKey Azure Storage Account Key to use to access Azure Blob Storage
    ## @param gateway.auth.azure.storageAccountNameExistingSecret Existing Secret name to extract Azure Storage Account Name from to access Azure Blob Storage
    ## @param gateway.auth.azure.storageAccountNameExistingSecretKey Existing Secret key to extract Azure Storage Account Name from to use to access Azure Blob Storage
    ## @param gateway.auth.azure.storageAccountKeyExistingSecret Existing Secret name to extract Azure Storage Account Key from to access Azure Blob Storage
    ## @param gateway.auth.azure.storageAccountKeyExistingSecretKey Existing Secret key to extract Azure Storage Account Key from to use to access Azure Blob Storage
    ##
    azure:
      accessKey: ""
      secretKey: ""
      serviceEndpoint: ""
      storageAccountName: ""
      storageAccountKey: ""
      storageAccountNameExistingSecret: ""
      storageAccountNameExistingSecretKey: ""
      storageAccountKeyExistingSecret: ""
      storageAccountKeyExistingSecretKey: ""
    ## Authentication configuration for GCS. Ignored unless type=gcs
    ## @param gateway.auth.gcs.accessKey Access key to access MinIO&reg; using GCS Gateway
    ## @param gateway.auth.gcs.secretKey Secret key to access MinIO&reg; using GCS Gateway
    ## @param gateway.auth.gcs.keyJSON Service Account key to access GCS
    ## @param gateway.auth.gcs.projectID GCP Project ID to use
    ##
    gcs:
      accessKey: ""
      secretKey: ""
      keyJSON: ""
      projectID: ""
    ## Authentication configuration for NAS. Ignored unless type=nas
    ## @param gateway.auth.nas.accessKey Access key to access MinIO&reg; using NAS Gateway
    ## @param gateway.auth.nas.secretKey Secret key to access MinIO&reg; using NAS Gateway
    ##
    nas:
      accessKey: ""
      secretKey: ""
    ## Authentication configuration for S3. Ignored unless type=s3
    ## @param gateway.auth.s3.accessKey Access key to use to access AWS S3
    ## @param gateway.auth.s3.secretKey Secret key to use to access AWS S3
    ## @param gateway.auth.s3.serviceEndpoint AWS S3 endpoint
    ##
    s3:
      accessKey: ""
      secretKey: ""
      serviceEndpoint: https://s3.amazonaws.com